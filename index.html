<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 8px;
            pointer-events: auto;
            min-width: 250px;
            backdrop-filter: blur(5px);
            border: 1px solid #444;
        }

        h1 {
            margin: 0 0 15px 0;
            font-size: 1.2rem;
            color: #ff9d00;
        }

        .control-group {
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 0.9rem;
            color: #ccc;
        }

        button {
            background: #444;
            color: white;
            border: 1px solid #666;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            font-weight: bold;
        }

        button:hover {
            background: #555;
        }

        button.active {
            background: #ff9d00;
            color: #000;
            border-color: #ff9d00;
        }

        .instructions {
            font-size: 0.8rem;
            color: #888;
            margin-top: 15px;
            font-style: italic;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            pointer-events: none;
        }

        .key-hint {
            color: #ff9d00;
            font-weight: bold;
        }

        #error-msg {
            color: #ff4444;
            display: none;
            font-size: 0.9rem;
            margin-top: 10px;
        }
    </style>
    <!-- Import Maps for Three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
    <div id="ui-panel">
        <h1>Rigged Model Viewer</h1>

        <div class="control-group">
            <button id="btn-toggle-anim" class="active">Animation: ACTIVE</button>
            <button id="btn-pose-mode">Mode: View</button>
            <label for="speedSlider">Speed</label>
            <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1.0">
            <button id="btn-export">Export GLTF</button>
        </div>

        <div class="control-group">
            <label>Movement:</label>
            <button id="btn-walk-fwd">Walk Forward</button>
            <button id="btn-walk-bwd">Walk Backward</button>
            <button id="btn-gallop">Gallop Forward</button>
            <button id="btn-stop" style="background: #822; border-color: #a44;">STOP</button>
        </div>

        <div class="control-group">
            <label>Actions:</label>
            <button id="btn-lie-down">Lie Down</button>
            <button id="btn-stand-up" disabled style="opacity: 0.5; cursor: not-allowed;">Stand Up</button>
            <button id="btn-prance">Prance</button>
            <button id="btn-kick">Kick</button>
            <button id="btn-shake-lr">Shake Head L/R</button>
            <button id="btn-shake-up">Shake Head Up</button>
        </div>
        <div id="instruction-text" class="instructions">Scroll to zoom.</div>
        <div id="debug-time" style="margin-top: 10px; font-family: monospace; color: #0f0;">Time: 0.00s</div>
    </div>
    <div id="error-msg"></div>

    <div id="loading">Loading scene.gltf...</div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // --- Configuration ---
        // Ranges in SECONDS. We will convert to frames.
        const ANIMATION_RANGES_SEC = {
            idle: { start: 0, end: 22 },
            walk_forward: { start: 29, end: 31 },
            walk_backward: { start: 31, end: 33 },
            gallop_forward: { start: 33, end: 35 },
            lie_down: { start: 38, end: 41 },
            stand_up: { start: 41, end: 42 },
            prance: { start: 42, end: 43 },
            kick: { start: 43, end: 45 },
            shake_head_lr: { start: 45, end: 47 },
            shake_head_up: { start: 47, end: 49 }
        };

        const MOVEMENT_SPEEDS = {
            walk_forward: 1.5,
            walk_backward: -0.8,
            gallop_forward: 5.0,
            idle: 0
        };

        const FPS = 30; // Assumed FPS for the clip

        // --- State ---
        let characterRoot, skeletonHelper, mixer;
        let actions = {};
        let currentState = 'idle';
        let animationRunning = true;
        let poseMode = false;
        let speedMultiplier = 1.0;
        let lastInputTime = Date.now();
        let isRandomActionPlaying = false;
        let isLyingDown = false;

        const clock = new THREE.Clock();
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const keys = {};

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 50;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Floor
        const gridHelper = new THREE.GridHelper(200, 200, 0x444444, 0x333333);
        scene.add(gridHelper);

        const planeGeo = new THREE.PlaneGeometry(200, 200);
        const planeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 1 });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);

        // --- Model Setup ---
        const modelContainer = new THREE.Group();
        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.addEventListener('dragging-changed', (event) => controls.enabled = !event.value);
        scene.add(transformControl);

        const loader = new GLTFLoader();

        loader.load('scene.gltf', function (gltf) {
            characterRoot = gltf.scene;
            modelContainer.add(characterRoot);
            scene.add(modelContainer);

            characterRoot.traverse(function (child) {
                if (child.isSkinnedMesh) {
                    skeletonHelper = new THREE.SkeletonHelper(child);
                    skeletonHelper.visible = false;
                    scene.add(skeletonHelper);
                }
            });

            if (gltf.animations.length > 0) {
                mixer = new THREE.AnimationMixer(characterRoot);
                const masterClip = gltf.animations[0]; // Assuming single "Animations" clip

                // Create sub-clips
                for (const [name, range] of Object.entries(ANIMATION_RANGES_SEC)) {
                    // Convert seconds to frames
                    const startFrame = Math.floor(range.start * FPS);
                    const endFrame = Math.floor(range.end * FPS);

                    const subClip = THREE.AnimationUtils.subclip(masterClip, name, startFrame, endFrame, FPS);
                    const action = mixer.clipAction(subClip);

                    // Configure loop modes
                    if (['lie_down', 'stand_up', 'kick', 'shake_head_lr', 'shake_head_up', 'prance'].includes(name)) {
                        action.setLoop(THREE.LoopOnce);
                        action.clampWhenFinished = true;
                    } else {
                        action.setLoop(THREE.LoopRepeat);
                    }

                    actions[name] = action;
                }

                // Create a special "idle_lying" action which is just the last frame of lie_down
                // We can just pause the lie_down action at the end, but having a loop is safer if we want breathing etc.
                // For now, clamping lie_down is enough.

                // Start Idle
                playAction('idle', 0.5);
            }

            document.getElementById('loading').style.display = 'none';
        }, undefined, function (error) {
            console.error(error);
            document.getElementById('error-msg').innerText = 'Failed to load scene.gltf';
            document.getElementById('error-msg').style.display = 'block';
        });

        // --- Animation Control ---
        function playAction(name, fadeDuration = 0.2) {
            if (!actions[name]) {
                console.warn(`Animation ${name} not found`);
                return;
            }
            if (currentState === name && actions[name].isRunning()) return;

            const prevAction = actions[currentState];
            const newAction = actions[name];

            if (prevAction && prevAction !== newAction) {
                prevAction.fadeOut(fadeDuration);
            }

            newAction.reset().fadeIn(fadeDuration).play();
            currentState = name;
            lastInputTime = Date.now();

            updateUI();
        }

        function updateUI() {
            // Update active button state
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            const btnId = 'btn-' + currentState.replace(/_/g, '-');
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.add('active');

            // Enable/Disable buttons based on isLyingDown
            const btnLieDown = document.getElementById('btn-lie-down');
            const btnStandUp = document.getElementById('btn-stand-up');
            const movementButtons = [
                'btn-walk-fwd', 'btn-walk-bwd', 'btn-gallop',
                'btn-prance', 'btn-kick', 'btn-shake-lr', 'btn-shake-up'
            ];

            if (isLyingDown) {
                btnLieDown.disabled = true;
                btnLieDown.style.opacity = '0.5';
                btnLieDown.style.cursor = 'not-allowed';

                btnStandUp.disabled = false;
                btnStandUp.style.opacity = '1';
                btnStandUp.style.cursor = 'pointer';

                movementButtons.forEach(id => {
                    const b = document.getElementById(id);
                    if (b) {
                        b.disabled = true;
                        b.style.opacity = '0.5';
                        b.style.cursor = 'not-allowed';
                    }
                });
            } else {
                btnLieDown.disabled = false;
                btnLieDown.style.opacity = '1';
                btnLieDown.style.cursor = 'pointer';

                btnStandUp.disabled = true;
                btnStandUp.style.opacity = '0.5';
                btnStandUp.style.cursor = 'not-allowed';

                movementButtons.forEach(id => {
                    const b = document.getElementById(id);
                    if (b) {
                        b.disabled = false;
                        b.style.opacity = '1';
                        b.style.cursor = 'pointer';
                    }
                });
            }
        }

        // --- Interaction ---
        function onMouseClick(event) {
            if (!characterRoot || !poseMode) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(characterRoot.children, true);
            if (intersects.length > 0) {
                transformControl.attach(intersects[0].object);
            } else {
                transformControl.detach();
            }
        }

        window.addEventListener('mousedown', onMouseClick);
        window.addEventListener('resize', onWindowResize, false);
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            lastInputTime = Date.now();
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- UI Logic ---
        const btnToggleAnim = document.getElementById('btn-toggle-anim');
        const btnPoseMode = document.getElementById('btn-pose-mode');
        const btnExport = document.getElementById('btn-export');
        const speedSlider = document.getElementById('speedSlider');
        const debugTime = document.getElementById('debug-time');

        // Map buttons to actions
        const buttonMap = {
            'btn-walk-fwd': 'walk_forward',
            'btn-walk-bwd': 'walk_backward',
            'btn-gallop': 'gallop_forward',
            'btn-lie-down': 'lie_down',
            'btn-stand-up': 'stand_up',
            'btn-prance': 'prance',
            'btn-kick': 'kick',
            'btn-shake-lr': 'shake_head_lr',
            'btn-shake-up': 'shake_head_up'
        };

        Object.entries(buttonMap).forEach(([btnId, actionName]) => {
            const btn = document.getElementById(btnId);
            if (btn) {
                btn.addEventListener('click', () => {
                    if (poseMode) return;
                    if (isLyingDown && actionName !== 'stand_up') return;
                    if (!isLyingDown && actionName === 'stand_up') return;

                    playAction(actionName);

                    // Handle One-Shot Actions
                    if (['lie_down', 'stand_up', 'kick', 'shake_head_lr', 'shake_head_up', 'prance'].includes(actionName)) {
                        isRandomActionPlaying = true;
                        const action = actions[actionName];

                        const onFinished = (e) => {
                            if (e.action === action) {
                                mixer.removeEventListener('finished', onFinished);
                                isRandomActionPlaying = false;

                                if (actionName === 'lie_down') {
                                    isLyingDown = true;
                                    updateUI();
                                    // Stay in lie_down state (clamped)
                                } else if (actionName === 'stand_up') {
                                    isLyingDown = false;
                                    updateUI();
                                    playAction('idle');
                                } else {
                                    playAction('idle');
                                }
                            }
                        };
                        mixer.addEventListener('finished', onFinished);
                    }
                });
            }
        });

        document.getElementById('btn-stop').addEventListener('click', () => {
            if (isLyingDown) return; // Can't stop to idle if lying down (must stand up first)
            playAction('idle');
        });

        if (btnToggleAnim) {
            btnToggleAnim.addEventListener('click', () => {
                animationRunning = !animationRunning;
                btnToggleAnim.classList.toggle('active');
                btnToggleAnim.innerText = animationRunning ? "Animation: ACTIVE" : "Animation: PAUSED";
            });
        }

        if (speedSlider) {
            speedSlider.addEventListener('input', (e) => {
                speedMultiplier = parseFloat(e.target.value);
            });
        }

        if (btnPoseMode) {
            btnPoseMode.addEventListener('click', () => {
                poseMode = !poseMode;
                if (poseMode) {
                    animationRunning = false;
                    btnToggleAnim.innerText = "Animation: PAUSED";
                    btnPoseMode.innerText = "Mode: Pose";
                    btnPoseMode.classList.add('active');
                    transformControl.setMode('rotate');
                    if (skeletonHelper) skeletonHelper.visible = true;
                } else {
                    poseMode = false;
                    animationRunning = true;
                    btnToggleAnim.innerText = "Animation: ACTIVE";
                    btnPoseMode.innerText = "Mode: View";
                    btnPoseMode.classList.remove('active');
                    transformControl.detach();
                    if (skeletonHelper) skeletonHelper.visible = false;
                }
            });
        }

        if (btnExport) {
            btnExport.addEventListener('click', () => {
                const exporter = new GLTFExporter();
                if (skeletonHelper) skeletonHelper.visible = false;
                transformControl.detach();
                exporter.parse(modelContainer, function (gltf) {
                    const output = JSON.stringify(gltf, null, 2);
                    const blob = new Blob([output], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = 'modified_scene.gltf';
                    link.click();
                    if (poseMode && skeletonHelper) skeletonHelper.visible = true;
                }, { binary: false });
            });
        }

        // --- Camera Follow & Logic ---
        const targetPosition = new THREE.Vector3();

        function updateLogic(delta) {
            if (mixer && animationRunning) {
                mixer.update(delta);
                // Debug Time
                if (actions[currentState]) {
                    const range = ANIMATION_RANGES_SEC[currentState];
                    if (range) {
                        // Approximate global time
                        const currentGlobalTime = range.start + actions[currentState].time;
                        debugTime.innerText = `Anim: ${currentState} | Time: ${currentGlobalTime.toFixed(2)}s`;
                    }
                }
            }

            if (!characterRoot || poseMode) return;

            // Idle Logic
            if (currentState === 'idle' && !isRandomActionPlaying && !isLyingDown) {
                if (Date.now() - lastInputTime > 5000) { // 5 seconds inactivity
                    // Pick random action
                    const randomActions = ['shake_head_lr', 'shake_head_up', 'prance', 'kick', 'lie_down'];
                    const nextAction = randomActions[Math.floor(Math.random() * randomActions.length)];

                    console.log("Triggering random idle action:", nextAction);
                    playAction(nextAction);
                    isRandomActionPlaying = true;

                    const action = actions[nextAction];
                    const onFinished = (e) => {
                        if (e.action === action) {
                            mixer.removeEventListener('finished', onFinished);
                            isRandomActionPlaying = false;

                            if (nextAction === 'lie_down') {
                                isLyingDown = true;
                                updateUI();
                                // Immediately stand up for random idle loop
                                playAction('stand_up');
                                isRandomActionPlaying = true;
                                const onStandFinished = (e2) => {
                                    if (e2.action === actions['stand_up']) {
                                        mixer.removeEventListener('finished', onStandFinished);
                                        isRandomActionPlaying = false;
                                        isLyingDown = false;
                                        updateUI();
                                        playAction('idle');
                                    }
                                };
                                mixer.addEventListener('finished', onStandFinished);
                            } else {
                                playAction('idle');
                            }
                        }
                    };
                    mixer.addEventListener('finished', onFinished);
                    lastInputTime = Date.now(); // Reset timer
                }
            }

            // Movement Logic (WASD)
            if (isLyingDown) return; // No movement if lying down

            let moveX = 0, moveZ = 0;
            if (keys['KeyW']) moveZ -= 1;
            if (keys['KeyS']) moveZ += 1;
            if (keys['KeyA']) moveX -= 1;
            if (keys['KeyD']) moveX += 1;

            const isMoving = (moveX !== 0 || moveZ !== 0);

            if (isMoving && !isRandomActionPlaying) {
                let targetAnim = 'walk_forward';
                if (moveZ > 0) targetAnim = 'walk_backward';

                if (currentState !== targetAnim && currentState !== 'gallop_forward') {
                    playAction(targetAnim);
                }

                // Rotation
                if (keys['KeyA']) {
                    modelContainer.rotation.y += 2.0 * delta;
                }
                if (keys['KeyD']) {
                    modelContainer.rotation.y -= 2.0 * delta;
                }

                // Movement
                if (keys['KeyW']) {
                    modelContainer.translateZ(MOVEMENT_SPEEDS.walk_forward * delta * speedMultiplier);
                } else if (keys['KeyS']) {
                    modelContainer.translateZ(Math.abs(MOVEMENT_SPEEDS.walk_backward) * delta * speedMultiplier);
                }

            } else if (!isMoving && !isRandomActionPlaying && ['walk_forward', 'walk_backward', 'gallop_forward'].includes(currentState)) {
                // Stopped moving keys -> Idle
                playAction('idle');
            }

            // Button triggered movement
            if (['walk_forward', 'gallop_forward'].includes(currentState) && !isMoving) {
                const speed = MOVEMENT_SPEEDS[currentState];
                modelContainer.translateZ(speed * delta * speedMultiplier * 0.05);
            } else if (currentState === 'walk_backward' && !isMoving) {
                const speed = MOVEMENT_SPEEDS[currentState];
                modelContainer.translateZ(speed * delta * speedMultiplier * 0.05);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            updateLogic(delta);

            // Camera Follow
            if (!poseMode && animationRunning) {
                targetPosition.copy(modelContainer.position);
                controls.target.lerp(targetPosition, 0.1);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>

</html>